// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: prototype/transaction.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "prototype/Transaction.pbobjc.h"
 #import "prototype/Type.pbobjc.h"
 #import "prototype/Operation.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - TransactionRoot

@implementation TransactionRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - TransactionRoot_FileDescriptor

static GPBFileDescriptor *TransactionRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"prototype"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - operation

@implementation operation

@dynamic opOneOfCase;
@dynamic op1;
@dynamic op2;
@dynamic op3;
@dynamic op4;
@dynamic op5;
@dynamic op6;
@dynamic op7;
@dynamic op8;
@dynamic op9;
@dynamic op10;
@dynamic op11;
@dynamic op12;
@dynamic op13;
@dynamic op14;
@dynamic op15;
@dynamic op16;

typedef struct operation__storage_ {
  uint32_t _has_storage_[2];
  account_create_operation *op1;
  transfer_operation *op2;
  bp_register_operation *op3;
  bp_unregister_operation *op4;
  bp_vote_operation *op5;
  post_operation *op6;
  reply_operation *op7;
  follow_operation *op8;
  vote_operation *op9;
  transfer_to_vesting_operation *op10;
  claim_operation *op11;
  claim_all_operation *op12;
  contract_deploy_operation *op13;
  contract_apply_operation *op14;
  report_operation *op15;
  convert_vesting_operation *op16;
} operation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "op1",
        .dataTypeSpecific.className = GPBStringifySymbol(account_create_operation),
        .number = operation_FieldNumber_Op1,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op2",
        .dataTypeSpecific.className = GPBStringifySymbol(transfer_operation),
        .number = operation_FieldNumber_Op2,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op3",
        .dataTypeSpecific.className = GPBStringifySymbol(bp_register_operation),
        .number = operation_FieldNumber_Op3,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op4",
        .dataTypeSpecific.className = GPBStringifySymbol(bp_unregister_operation),
        .number = operation_FieldNumber_Op4,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op4),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op5",
        .dataTypeSpecific.className = GPBStringifySymbol(bp_vote_operation),
        .number = operation_FieldNumber_Op5,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op6",
        .dataTypeSpecific.className = GPBStringifySymbol(post_operation),
        .number = operation_FieldNumber_Op6,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op7",
        .dataTypeSpecific.className = GPBStringifySymbol(reply_operation),
        .number = operation_FieldNumber_Op7,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op8",
        .dataTypeSpecific.className = GPBStringifySymbol(follow_operation),
        .number = operation_FieldNumber_Op8,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op8),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op9",
        .dataTypeSpecific.className = GPBStringifySymbol(vote_operation),
        .number = operation_FieldNumber_Op9,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op9),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op10",
        .dataTypeSpecific.className = GPBStringifySymbol(transfer_to_vesting_operation),
        .number = operation_FieldNumber_Op10,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op10),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op11",
        .dataTypeSpecific.className = GPBStringifySymbol(claim_operation),
        .number = operation_FieldNumber_Op11,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op11),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op12",
        .dataTypeSpecific.className = GPBStringifySymbol(claim_all_operation),
        .number = operation_FieldNumber_Op12,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op12),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op13",
        .dataTypeSpecific.className = GPBStringifySymbol(contract_deploy_operation),
        .number = operation_FieldNumber_Op13,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op13),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op14",
        .dataTypeSpecific.className = GPBStringifySymbol(contract_apply_operation),
        .number = operation_FieldNumber_Op14,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op14),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op15",
        .dataTypeSpecific.className = GPBStringifySymbol(report_operation),
        .number = operation_FieldNumber_Op15,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op15),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "op16",
        .dataTypeSpecific.className = GPBStringifySymbol(convert_vesting_operation),
        .number = operation_FieldNumber_Op16,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(operation__storage_, op16),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[operation class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(operation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "op",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void operation_ClearOpOneOfCase(operation *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - transaction

@implementation transaction

@dynamic refBlockNum;
@dynamic refBlockPrefix;
@dynamic hasExpiration, expiration;
@dynamic operationsArray, operationsArray_Count;

typedef struct transaction__storage_ {
  uint32_t _has_storage_[1];
  uint32_t refBlockNum;
  uint32_t refBlockPrefix;
  time_point_sec *expiration;
  NSMutableArray *operationsArray;
} transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "refBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = transaction_FieldNumber_RefBlockNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(transaction__storage_, refBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "refBlockPrefix",
        .dataTypeSpecific.className = NULL,
        .number = transaction_FieldNumber_RefBlockPrefix,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(transaction__storage_, refBlockPrefix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = transaction_FieldNumber_Expiration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(transaction__storage_, expiration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(operation),
        .number = transaction_FieldNumber_OperationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(transaction__storage_, operationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[transaction class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - signed_transaction

@implementation signed_transaction

@dynamic hasTrx, trx;
@dynamic hasSignature, signature;

typedef struct signed_transaction__storage_ {
  uint32_t _has_storage_[1];
  transaction *trx;
  signature_type *signature;
} signed_transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trx",
        .dataTypeSpecific.className = GPBStringifySymbol(transaction),
        .number = signed_transaction_FieldNumber_Trx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(signed_transaction__storage_, trx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = GPBStringifySymbol(signature_type),
        .number = signed_transaction_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(signed_transaction__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[signed_transaction class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(signed_transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - operation_receipt_with_info

@implementation operation_receipt_with_info

@dynamic status;
@dynamic gasUsage;
@dynamic vmConsole;

typedef struct operation_receipt_with_info__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  NSString *vmConsole;
  uint64_t gasUsage;
} operation_receipt_with_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = operation_receipt_with_info_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(operation_receipt_with_info__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gasUsage",
        .dataTypeSpecific.className = NULL,
        .number = operation_receipt_with_info_FieldNumber_GasUsage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(operation_receipt_with_info__storage_, gasUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "vmConsole",
        .dataTypeSpecific.className = NULL,
        .number = operation_receipt_with_info_FieldNumber_VmConsole,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(operation_receipt_with_info__storage_, vmConsole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[operation_receipt_with_info class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(operation_receipt_with_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - operation_receipt

@implementation operation_receipt

@dynamic status;

typedef struct operation_receipt__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
} operation_receipt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = operation_receipt_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(operation_receipt__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[operation_receipt class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(operation_receipt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - transaction_receipt

@implementation transaction_receipt

@dynamic status;
@dynamic totalGasUsage;
@dynamic opResultsArray, opResultsArray_Count;

typedef struct transaction_receipt__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  NSMutableArray *opResultsArray;
  uint64_t totalGasUsage;
} transaction_receipt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = transaction_receipt_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(transaction_receipt__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalGasUsage",
        .dataTypeSpecific.className = NULL,
        .number = transaction_receipt_FieldNumber_TotalGasUsage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(transaction_receipt__storage_, totalGasUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "opResultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(operation_receipt),
        .number = transaction_receipt_FieldNumber_OpResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(transaction_receipt__storage_, opResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[transaction_receipt class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(transaction_receipt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - transaction_receipt_with_info

@implementation transaction_receipt_with_info

@dynamic status;
@dynamic totalGasUsage;
@dynamic errorInfo;
@dynamic opResultsArray, opResultsArray_Count;

typedef struct transaction_receipt_with_info__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  NSString *errorInfo;
  NSMutableArray *opResultsArray;
  uint64_t totalGasUsage;
} transaction_receipt_with_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = transaction_receipt_with_info_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(transaction_receipt_with_info__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalGasUsage",
        .dataTypeSpecific.className = NULL,
        .number = transaction_receipt_with_info_FieldNumber_TotalGasUsage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(transaction_receipt_with_info__storage_, totalGasUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "errorInfo",
        .dataTypeSpecific.className = NULL,
        .number = transaction_receipt_with_info_FieldNumber_ErrorInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(transaction_receipt_with_info__storage_, errorInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opResultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(operation_receipt_with_info),
        .number = transaction_receipt_with_info_FieldNumber_OpResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(transaction_receipt_with_info__storage_, opResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[transaction_receipt_with_info class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(transaction_receipt_with_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - estimate_trx_result

@implementation estimate_trx_result

@dynamic hasSigTrx, sigTrx;
@dynamic hasReceipt, receipt;

typedef struct estimate_trx_result__storage_ {
  uint32_t _has_storage_[1];
  signed_transaction *sigTrx;
  transaction_receipt_with_info *receipt;
} estimate_trx_result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sigTrx",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_transaction),
        .number = estimate_trx_result_FieldNumber_SigTrx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(estimate_trx_result__storage_, sigTrx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = GPBStringifySymbol(transaction_receipt_with_info),
        .number = estimate_trx_result_FieldNumber_Receipt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(estimate_trx_result__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[estimate_trx_result class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(estimate_trx_result__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - transaction_wrapper

@implementation transaction_wrapper

@dynamic hasSigTrx, sigTrx;
@dynamic hasInvoice, invoice;

typedef struct transaction_wrapper__storage_ {
  uint32_t _has_storage_[1];
  signed_transaction *sigTrx;
  transaction_receipt *invoice;
} transaction_wrapper__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sigTrx",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_transaction),
        .number = transaction_wrapper_FieldNumber_SigTrx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(transaction_wrapper__storage_, sigTrx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "invoice",
        .dataTypeSpecific.className = GPBStringifySymbol(transaction_receipt),
        .number = transaction_wrapper_FieldNumber_Invoice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(transaction_wrapper__storage_, invoice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[transaction_wrapper class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(transaction_wrapper__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - block_header

@implementation block_header

@dynamic hasPrevious, previous;
@dynamic hasTimestamp, timestamp;
@dynamic hasWitness, witness;
@dynamic hasTransactionMerkleRoot, transactionMerkleRoot;

typedef struct block_header__storage_ {
  uint32_t _has_storage_[1];
  sha256 *previous;
  time_point_sec *timestamp;
  account_name *witness;
  sha256 *transactionMerkleRoot;
} block_header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "previous",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = block_header_FieldNumber_Previous,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(block_header__storage_, previous),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = block_header_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(block_header__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witness",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = block_header_FieldNumber_Witness,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(block_header__storage_, witness),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionMerkleRoot",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = block_header_FieldNumber_TransactionMerkleRoot,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(block_header__storage_, transactionMerkleRoot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[block_header class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(block_header__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - signed_block_header

@implementation signed_block_header

@dynamic hasHeader, header;
@dynamic hasWitnessSignature, witnessSignature;

typedef struct signed_block_header__storage_ {
  uint32_t _has_storage_[1];
  block_header *header;
  signature_type *witnessSignature;
} signed_block_header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(block_header),
        .number = signed_block_header_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(signed_block_header__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witnessSignature",
        .dataTypeSpecific.className = GPBStringifySymbol(signature_type),
        .number = signed_block_header_FieldNumber_WitnessSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(signed_block_header__storage_, witnessSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[signed_block_header class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(signed_block_header__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - signed_block

@implementation signed_block

@dynamic hasSignedHeader, signedHeader;
@dynamic transactionsArray, transactionsArray_Count;

typedef struct signed_block__storage_ {
  uint32_t _has_storage_[1];
  signed_block_header *signedHeader;
  NSMutableArray *transactionsArray;
} signed_block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signedHeader",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_block_header),
        .number = signed_block_FieldNumber_SignedHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(signed_block__storage_, signedHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(transaction_wrapper),
        .number = signed_block_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(signed_block__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[signed_block class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(signed_block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - empty_signed_block

@implementation empty_signed_block

@dynamic hasSignedHeader, signedHeader;
@dynamic trxCount;

typedef struct empty_signed_block__storage_ {
  uint32_t _has_storage_[1];
  uint32_t trxCount;
  signed_block_header *signedHeader;
} empty_signed_block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signedHeader",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_block_header),
        .number = empty_signed_block_FieldNumber_SignedHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(empty_signed_block__storage_, signedHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trxCount",
        .dataTypeSpecific.className = NULL,
        .number = empty_signed_block_FieldNumber_TrxCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(empty_signed_block__storage_, trxCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[empty_signed_block class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(empty_signed_block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
