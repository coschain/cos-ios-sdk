// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Grpc.pbobjc.h"
 #import "prototype/Type.pbobjc.h"
 #import "prototype/MultiId.pbobjc.h"
 #import "prototype/Transaction.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GrpcRoot

@implementation GrpcRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - GrpcRoot_FileDescriptor

static GPBFileDescriptor *GrpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"grpcpb"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GetTableContentRequest

@implementation GetTableContentRequest

@dynamic owner;
@dynamic contract;
@dynamic table;
@dynamic field;
@dynamic begin;
@dynamic count;
@dynamic reverse;

typedef struct GetTableContentRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSString *owner;
  NSString *contract;
  NSString *table;
  NSString *field;
  NSString *begin;
} GetTableContentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Owner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTableContentRequest__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contract",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Contract,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTableContentRequest__storage_, contract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "table",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Table,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTableContentRequest__storage_, table),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "field",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Field,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetTableContentRequest__storage_, field),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "begin",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Begin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetTableContentRequest__storage_, begin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Count,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetTableContentRequest__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "reverse",
        .dataTypeSpecific.className = NULL,
        .number = GetTableContentRequest_FieldNumber_Reverse,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTableContentRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTableContentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TableContentResponse

@implementation TableContentResponse

@dynamic tableContent;

typedef struct TableContentResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *tableContent;
} TableContentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tableContent",
        .dataTypeSpecific.className = NULL,
        .number = TableContentResponse_FieldNumber_TableContent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TableContentResponse__storage_, tableContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TableContentResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TableContentResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountByNameRequest

@implementation GetAccountByNameRequest

@dynamic hasAccountName, accountName;

typedef struct GetAccountByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
} GetAccountByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetAccountByNameRequest_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountByNameRequest__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountByNameRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountCashoutRequest

@implementation GetAccountCashoutRequest

@dynamic hasAccountName, accountName;
@dynamic postId;

typedef struct GetAccountCashoutRequest__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
  uint64_t postId;
} GetAccountCashoutRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetAccountCashoutRequest_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountCashoutRequest__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "postId",
        .dataTypeSpecific.className = NULL,
        .number = GetAccountCashoutRequest_FieldNumber_PostId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountCashoutRequest__storage_, postId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountCashoutRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountCashoutRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountCashoutResponse

@implementation AccountCashoutResponse

@dynamic hasAccountName, accountName;
@dynamic hasReward, reward;

typedef struct AccountCashoutResponse__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
  vest *reward;
} AccountCashoutResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = AccountCashoutResponse_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountCashoutResponse__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reward",
        .dataTypeSpecific.className = GPBStringifySymbol(vest),
        .number = AccountCashoutResponse_FieldNumber_Reward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountCashoutResponse__storage_, reward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountCashoutResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountCashoutResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockCashoutRequest

@implementation GetBlockCashoutRequest

@dynamic blockHeight;

typedef struct GetBlockCashoutRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t blockHeight;
} GetBlockCashoutRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockCashoutRequest_FieldNumber_BlockHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockCashoutRequest__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockCashoutRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockCashoutRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockCashoutResponse

@implementation BlockCashoutResponse

@dynamic cashoutListArray, cashoutListArray_Count;

typedef struct BlockCashoutResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cashoutListArray;
} BlockCashoutResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cashoutListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountCashoutResponse),
        .number = BlockCashoutResponse_FieldNumber_CashoutListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockCashoutResponse__storage_, cashoutListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockCashoutResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockCashoutResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountRewardByNameRequest

@implementation GetAccountRewardByNameRequest

@dynamic hasAccountName, accountName;

typedef struct GetAccountRewardByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
} GetAccountRewardByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetAccountRewardByNameRequest_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountRewardByNameRequest__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountRewardByNameRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountRewardByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountRewardResponse

@implementation AccountRewardResponse

@dynamic hasAccountName, accountName;
@dynamic hasReward, reward;

typedef struct AccountRewardResponse__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
  vest *reward;
} AccountRewardResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = AccountRewardResponse_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountRewardResponse__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reward",
        .dataTypeSpecific.className = GPBStringifySymbol(vest),
        .number = AccountRewardResponse_FieldNumber_Reward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountRewardResponse__storage_, reward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountRewardResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountRewardResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountInfo

@implementation AccountInfo

@dynamic hasAccountName, accountName;
@dynamic hasCoin, coin;
@dynamic hasVest, vest;
@dynamic hasPublicKey, publicKey;
@dynamic hasCreatedTime, createdTime;
@dynamic hasWitness, witness;
@dynamic postCount;
@dynamic followerCount;
@dynamic followingCount;
@dynamic trxCount;
@dynamic votePower;

typedef struct AccountInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t postCount;
  uint32_t followerCount;
  uint32_t followingCount;
  uint32_t trxCount;
  uint32_t votePower;
  account_name *accountName;
  coin *coin;
  vest *vest;
  public_key_type *publicKey;
  time_point_sec *createdTime;
  WitnessResponse *witness;
} AccountInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = AccountInfo_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coin",
        .dataTypeSpecific.className = GPBStringifySymbol(coin),
        .number = AccountInfo_FieldNumber_Coin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, coin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vest",
        .dataTypeSpecific.className = GPBStringifySymbol(vest),
        .number = AccountInfo_FieldNumber_Vest,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, vest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = GPBStringifySymbol(public_key_type),
        .number = AccountInfo_FieldNumber_PublicKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = AccountInfo_FieldNumber_CreatedTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, createdTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witness",
        .dataTypeSpecific.className = GPBStringifySymbol(WitnessResponse),
        .number = AccountInfo_FieldNumber_Witness,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, witness),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "postCount",
        .dataTypeSpecific.className = NULL,
        .number = AccountInfo_FieldNumber_PostCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, postCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "followerCount",
        .dataTypeSpecific.className = NULL,
        .number = AccountInfo_FieldNumber_FollowerCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, followerCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "followingCount",
        .dataTypeSpecific.className = NULL,
        .number = AccountInfo_FieldNumber_FollowingCount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, followingCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "trxCount",
        .dataTypeSpecific.className = NULL,
        .number = AccountInfo_FieldNumber_TrxCount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, trxCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "votePower",
        .dataTypeSpecific.className = NULL,
        .number = AccountInfo_FieldNumber_VotePower,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AccountInfo__storage_, votePower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountInfo class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountResponse

@implementation AccountResponse

@dynamic hasInfo, info;
@dynamic hasState, state;

typedef struct AccountResponse__storage_ {
  uint32_t _has_storage_[1];
  AccountInfo *info;
  ChainState *state;
} AccountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountInfo),
        .number = AccountResponse_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainState),
        .number = AccountResponse_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFollowerListByNameRequest

@implementation GetFollowerListByNameRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic limit;
@dynamic hasLastOrder, lastOrder;

typedef struct GetFollowerListByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  follower_created_order *start;
  follower_created_order *end;
  follower_created_order *lastOrder;
} GetFollowerListByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(follower_created_order),
        .number = GetFollowerListByNameRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFollowerListByNameRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(follower_created_order),
        .number = GetFollowerListByNameRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetFollowerListByNameRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetFollowerListByNameRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetFollowerListByNameRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastOrder",
        .dataTypeSpecific.className = GPBStringifySymbol(follower_created_order),
        .number = GetFollowerListByNameRequest_FieldNumber_LastOrder,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetFollowerListByNameRequest__storage_, lastOrder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFollowerListByNameRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFollowerListByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FollowerListInfo

@implementation FollowerListInfo

@dynamic hasAccount, account;
@dynamic hasCreateOrder, createOrder;

typedef struct FollowerListInfo__storage_ {
  uint32_t _has_storage_[1];
  AccountResponse *account;
  follower_created_order *createOrder;
} FollowerListInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountResponse),
        .number = FollowerListInfo_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FollowerListInfo__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createOrder",
        .dataTypeSpecific.className = GPBStringifySymbol(follower_created_order),
        .number = FollowerListInfo_FieldNumber_CreateOrder,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FollowerListInfo__storage_, createOrder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FollowerListInfo class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FollowerListInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFollowerListByNameResponse

@implementation GetFollowerListByNameResponse

@dynamic followerListArray, followerListArray_Count;

typedef struct GetFollowerListByNameResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *followerListArray;
} GetFollowerListByNameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "followerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FollowerListInfo),
        .number = GetFollowerListByNameResponse_FieldNumber_FollowerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetFollowerListByNameResponse__storage_, followerListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFollowerListByNameResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFollowerListByNameResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFollowingListByNameRequest

@implementation GetFollowingListByNameRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic limit;
@dynamic hasLastOrder, lastOrder;

typedef struct GetFollowingListByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  following_created_order *start;
  following_created_order *end;
  following_created_order *lastOrder;
} GetFollowingListByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(following_created_order),
        .number = GetFollowingListByNameRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFollowingListByNameRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(following_created_order),
        .number = GetFollowingListByNameRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetFollowingListByNameRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetFollowingListByNameRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetFollowingListByNameRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastOrder",
        .dataTypeSpecific.className = GPBStringifySymbol(following_created_order),
        .number = GetFollowingListByNameRequest_FieldNumber_LastOrder,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetFollowingListByNameRequest__storage_, lastOrder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFollowingListByNameRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFollowingListByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FollowingListInfo

@implementation FollowingListInfo

@dynamic hasAccount, account;
@dynamic hasCreateOrder, createOrder;

typedef struct FollowingListInfo__storage_ {
  uint32_t _has_storage_[1];
  AccountResponse *account;
  following_created_order *createOrder;
} FollowingListInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountResponse),
        .number = FollowingListInfo_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FollowingListInfo__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createOrder",
        .dataTypeSpecific.className = GPBStringifySymbol(following_created_order),
        .number = FollowingListInfo_FieldNumber_CreateOrder,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FollowingListInfo__storage_, createOrder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FollowingListInfo class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FollowingListInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFollowingListByNameResponse

@implementation GetFollowingListByNameResponse

@dynamic followingListArray, followingListArray_Count;

typedef struct GetFollowingListByNameResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *followingListArray;
} GetFollowingListByNameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "followingListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FollowingListInfo),
        .number = GetFollowingListByNameResponse_FieldNumber_FollowingListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetFollowingListByNameResponse__storage_, followingListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFollowingListByNameResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFollowingListByNameResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFollowCountByNameRequest

@implementation GetFollowCountByNameRequest

@dynamic hasAccountName, accountName;

typedef struct GetFollowCountByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
} GetFollowCountByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetFollowCountByNameRequest_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFollowCountByNameRequest__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFollowCountByNameRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFollowCountByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFollowCountByNameResponse

@implementation GetFollowCountByNameResponse

@dynamic ferCnt;
@dynamic fingCnt;

typedef struct GetFollowCountByNameResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ferCnt;
  uint32_t fingCnt;
} GetFollowCountByNameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ferCnt",
        .dataTypeSpecific.className = NULL,
        .number = GetFollowCountByNameResponse_FieldNumber_FerCnt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFollowCountByNameResponse__storage_, ferCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fingCnt",
        .dataTypeSpecific.className = NULL,
        .number = GetFollowCountByNameResponse_FieldNumber_FingCnt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetFollowCountByNameResponse__storage_, fingCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFollowCountByNameResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFollowCountByNameResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WitnessResponse

@implementation WitnessResponse

@dynamic hasOwner, owner;
@dynamic hasCreatedTime, createdTime;
@dynamic URL;
@dynamic lastConfirmedBlockNum;
@dynamic totalMissed;
@dynamic voteCount;
@dynamic hasSigningKey, signingKey;
@dynamic hasLastWork, lastWork;
@dynamic runningVersion;

typedef struct WitnessResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t runningVersion;
  uint32_t lastConfirmedBlockNum;
  uint32_t totalMissed;
  account_name *owner;
  time_point_sec *createdTime;
  NSString *URL;
  public_key_type *signingKey;
  sha256 *lastWork;
  uint64_t voteCount;
} WitnessResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "owner",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = WitnessResponse_FieldNumber_Owner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "runningVersion",
        .dataTypeSpecific.className = NULL,
        .number = WitnessResponse_FieldNumber_RunningVersion,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, runningVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = WitnessResponse_FieldNumber_CreatedTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, createdTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = WitnessResponse_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastConfirmedBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = WitnessResponse_FieldNumber_LastConfirmedBlockNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, lastConfirmedBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalMissed",
        .dataTypeSpecific.className = NULL,
        .number = WitnessResponse_FieldNumber_TotalMissed,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, totalMissed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = WitnessResponse_FieldNumber_VoteCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, voteCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "signingKey",
        .dataTypeSpecific.className = GPBStringifySymbol(public_key_type),
        .number = WitnessResponse_FieldNumber_SigningKey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, signingKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastWork",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = WitnessResponse_FieldNumber_LastWork,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(WitnessResponse__storage_, lastWork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WitnessResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WitnessResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetWitnessListRequest

@implementation GetWitnessListRequest

@dynamic hasStart, start;
@dynamic limit;

typedef struct GetWitnessListRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  account_name *start;
} GetWitnessListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetWitnessListRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetWitnessListRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetWitnessListRequest_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetWitnessListRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetWitnessListRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetWitnessListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetWitnessListResponse

@implementation GetWitnessListResponse

@dynamic witnessListArray, witnessListArray_Count;

typedef struct GetWitnessListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *witnessListArray;
} GetWitnessListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "witnessListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WitnessResponse),
        .number = GetWitnessListResponse_FieldNumber_WitnessListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetWitnessListResponse__storage_, witnessListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetWitnessListResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetWitnessListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PostResponse

@implementation PostResponse

@dynamic postId;
@dynamic category;
@dynamic hasParentAuthor, parentAuthor;
@dynamic hasAuthor, author;
@dynamic title;
@dynamic body;
@dynamic hasCreated, created;
@dynamic hasLastPayout, lastPayout;
@dynamic depth;
@dynamic children;
@dynamic rootId;
@dynamic parentId;
@dynamic tagsArray, tagsArray_Count;
@dynamic beneficiariesArray, beneficiariesArray_Count;
@dynamic voteCnt;
@dynamic weightedVp;
@dynamic hasRewards, rewards;
@dynamic hasDappRewards, dappRewards;
@dynamic cashoutInterval;
@dynamic hasGlobalRewards, globalRewards;
@dynamic globalWeightedVp;

typedef struct PostResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t depth;
  uint32_t children;
  NSString *category;
  account_name *parentAuthor;
  account_name *author;
  NSString *title;
  NSString *body;
  time_point_sec *created;
  time_point_sec *lastPayout;
  NSMutableArray *tagsArray;
  NSMutableArray *beneficiariesArray;
  vest *rewards;
  vest *dappRewards;
  vest *globalRewards;
  uint64_t postId;
  uint64_t rootId;
  uint64_t parentId;
  uint64_t voteCnt;
  uint64_t weightedVp;
  uint64_t cashoutInterval;
  uint64_t globalWeightedVp;
} PostResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postId",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_PostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PostResponse__storage_, postId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PostResponse__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parentAuthor",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = PostResponse_FieldNumber_ParentAuthor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PostResponse__storage_, parentAuthor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "author",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = PostResponse_FieldNumber_Author,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PostResponse__storage_, author),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_Title,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PostResponse__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_Body,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PostResponse__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = PostResponse_FieldNumber_Created,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PostResponse__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPayout",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = PostResponse_FieldNumber_LastPayout,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PostResponse__storage_, lastPayout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "depth",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_Depth,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PostResponse__storage_, depth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "children",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_Children,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(PostResponse__storage_, children),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rootId",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_RootId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(PostResponse__storage_, rootId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "parentId",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_ParentId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(PostResponse__storage_, parentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PostResponse__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "beneficiariesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(beneficiary_route_type),
        .number = PostResponse_FieldNumber_BeneficiariesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PostResponse__storage_, beneficiariesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voteCnt",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_VoteCnt,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(PostResponse__storage_, voteCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "weightedVp",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_WeightedVp,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(PostResponse__storage_, weightedVp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rewards",
        .dataTypeSpecific.className = GPBStringifySymbol(vest),
        .number = PostResponse_FieldNumber_Rewards,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(PostResponse__storage_, rewards),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dappRewards",
        .dataTypeSpecific.className = GPBStringifySymbol(vest),
        .number = PostResponse_FieldNumber_DappRewards,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(PostResponse__storage_, dappRewards),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cashoutInterval",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_CashoutInterval,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(PostResponse__storage_, cashoutInterval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "globalRewards",
        .dataTypeSpecific.className = GPBStringifySymbol(vest),
        .number = PostResponse_FieldNumber_GlobalRewards,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(PostResponse__storage_, globalRewards),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "globalWeightedVp",
        .dataTypeSpecific.className = NULL,
        .number = PostResponse_FieldNumber_GlobalWeightedVp,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(PostResponse__storage_, globalWeightedVp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PostResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PostResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostListByCreatedRequest

@implementation GetPostListByCreatedRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic limit;

typedef struct GetPostListByCreatedRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  post_created_order *start;
  post_created_order *end;
} GetPostListByCreatedRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(post_created_order),
        .number = GetPostListByCreatedRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPostListByCreatedRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(post_created_order),
        .number = GetPostListByCreatedRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPostListByCreatedRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetPostListByCreatedRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPostListByCreatedRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostListByCreatedRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostListByCreatedRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostListByCreatedResponse

@implementation GetPostListByCreatedResponse

@dynamic postListArray, postListArray_Count;

typedef struct GetPostListByCreatedResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *postListArray;
} GetPostListByCreatedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetPostListByCreatedResponse_FieldNumber_PostListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPostListByCreatedResponse__storage_, postListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostListByCreatedResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostListByCreatedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetReplyListByPostIdRequest

@implementation GetReplyListByPostIdRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic limit;

typedef struct GetReplyListByPostIdRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  reply_created_order *start;
  reply_created_order *end;
} GetReplyListByPostIdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(reply_created_order),
        .number = GetReplyListByPostIdRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetReplyListByPostIdRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(reply_created_order),
        .number = GetReplyListByPostIdRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetReplyListByPostIdRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetReplyListByPostIdRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetReplyListByPostIdRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetReplyListByPostIdRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetReplyListByPostIdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetReplyListByPostIdResponse

@implementation GetReplyListByPostIdResponse

@dynamic replyListArray, replyListArray_Count;

typedef struct GetReplyListByPostIdResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *replyListArray;
} GetReplyListByPostIdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "replyListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetReplyListByPostIdResponse_FieldNumber_ReplyListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetReplyListByPostIdResponse__storage_, replyListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetReplyListByPostIdResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetReplyListByPostIdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockTransactionsByNumRequest

@implementation GetBlockTransactionsByNumRequest

@dynamic blockNum;
@dynamic start;
@dynamic limit;

typedef struct GetBlockTransactionsByNumRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t blockNum;
  uint32_t start;
  uint32_t limit;
} GetBlockTransactionsByNumRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNum",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockTransactionsByNumRequest_FieldNumber_BlockNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockTransactionsByNumRequest__storage_, blockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockTransactionsByNumRequest_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetBlockTransactionsByNumRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockTransactionsByNumRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetBlockTransactionsByNumRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockTransactionsByNumRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockTransactionsByNumRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockTransactionsByNumResponse

@implementation GetBlockTransactionsByNumResponse

@dynamic transactionsArray, transactionsArray_Count;

typedef struct GetBlockTransactionsByNumResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} GetBlockTransactionsByNumResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_transaction),
        .number = GetBlockTransactionsByNumResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetBlockTransactionsByNumResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockTransactionsByNumResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockTransactionsByNumResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetChainStateResponse

@implementation GetChainStateResponse

@dynamic hasState, state;

typedef struct GetChainStateResponse__storage_ {
  uint32_t _has_storage_[1];
  ChainState *state;
} GetChainStateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainState),
        .number = GetChainStateResponse_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetChainStateResponse__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetChainStateResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetChainStateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetStatResponse

@implementation GetStatResponse

@dynamic hasState, state;
@dynamic dailyTrxCountsArray, dailyTrxCountsArray_Count;

typedef struct GetStatResponse__storage_ {
  uint32_t _has_storage_[1];
  ChainState *state;
  GPBInt32Array *dailyTrxCountsArray;
} GetStatResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainState),
        .number = GetStatResponse_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetStatResponse__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dailyTrxCountsArray",
        .dataTypeSpecific.className = NULL,
        .number = GetStatResponse_FieldNumber_DailyTrxCountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetStatResponse__storage_, dailyTrxCountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetStatResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetStatResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastTrxRequest

@implementation BroadcastTrxRequest

@dynamic hasTransaction, transaction;
@dynamic onlyDeliver;

typedef struct BroadcastTrxRequest__storage_ {
  uint32_t _has_storage_[1];
  signed_transaction *transaction;
} BroadcastTrxRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_transaction),
        .number = BroadcastTrxRequest_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastTrxRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "onlyDeliver",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastTrxRequest_FieldNumber_OnlyDeliver,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastTrxRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastTrxRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastTrxResponse

@implementation BroadcastTrxResponse

@dynamic hasInvoice, invoice;
@dynamic status;
@dynamic msg;

typedef struct BroadcastTrxResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  transaction_receipt_with_info *invoice;
  NSString *msg;
} BroadcastTrxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invoice",
        .dataTypeSpecific.className = GPBStringifySymbol(transaction_receipt_with_info),
        .number = BroadcastTrxResponse_FieldNumber_Invoice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastTrxResponse__storage_, invoice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastTrxResponse_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BroadcastTrxResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastTrxResponse_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BroadcastTrxResponse__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastTrxResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastTrxResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NonParamsRequest

@implementation NonParamsRequest


typedef struct NonParamsRequest__storage_ {
  uint32_t _has_storage_[1];
} NonParamsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NonParamsRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NonParamsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CallResponse

@implementation CallResponse

@dynamic result;
@dynamic executeErr;
@dynamic estimateGas;

typedef struct CallResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *result;
  NSString *executeErr;
  NSString *estimateGas;
} CallResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = CallResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallResponse__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "executeErr",
        .dataTypeSpecific.className = NULL,
        .number = CallResponse_FieldNumber_ExecuteErr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallResponse__storage_, executeErr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "estimateGas",
        .dataTypeSpecific.className = NULL,
        .number = CallResponse_FieldNumber_EstimateGas,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CallResponse__storage_, estimateGas),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainState

@implementation ChainState

@dynamic lastIrreversibleBlockNumber;
@dynamic lastIrreversibleBlockTime;
@dynamic hasDgpo, dgpo;

typedef struct ChainState__storage_ {
  uint32_t _has_storage_[1];
  dynamic_properties *dgpo;
  uint64_t lastIrreversibleBlockNumber;
  uint64_t lastIrreversibleBlockTime;
} ChainState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastIrreversibleBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = ChainState_FieldNumber_LastIrreversibleBlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainState__storage_, lastIrreversibleBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastIrreversibleBlockTime",
        .dataTypeSpecific.className = NULL,
        .number = ChainState_FieldNumber_LastIrreversibleBlockTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainState__storage_, lastIrreversibleBlockTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "dgpo",
        .dataTypeSpecific.className = GPBStringifySymbol(dynamic_properties),
        .number = ChainState_FieldNumber_Dgpo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChainState__storage_, dgpo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainState class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockListRequest

@implementation GetBlockListRequest

@dynamic start;
@dynamic end;
@dynamic limit;

typedef struct GetBlockListRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  uint64_t start;
  uint64_t end;
} GetBlockListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockListRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockListRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockListRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetBlockListRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockListRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetBlockListRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockListRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockInfo

@implementation BlockInfo

@dynamic hasTimestamp, timestamp;
@dynamic blockHeight;
@dynamic trxCount;
@dynamic hasWitness, witness;
@dynamic hasBlockId, blockId;
@dynamic hasPreId, preId;
@dynamic blockSize;

typedef struct BlockInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t trxCount;
  uint32_t blockSize;
  time_point_sec *timestamp;
  account_name *witness;
  sha256 *blockId;
  sha256 *preId;
  uint64_t blockHeight;
} BlockInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = BlockInfo_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = BlockInfo_FieldNumber_BlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "trxCount",
        .dataTypeSpecific.className = NULL,
        .number = BlockInfo_FieldNumber_TrxCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, trxCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "witness",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = BlockInfo_FieldNumber_Witness,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, witness),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = BlockInfo_FieldNumber_BlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preId",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = BlockInfo_FieldNumber_PreId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, preId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockSize",
        .dataTypeSpecific.className = NULL,
        .number = BlockInfo_FieldNumber_BlockSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, blockSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInfo class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockListResponse

@implementation GetBlockListResponse

@dynamic blocksArray, blocksArray_Count;

typedef struct GetBlockListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
} GetBlockListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockInfo),
        .number = GetBlockListResponse_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetBlockListResponse__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockListResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSignedBlockRequest

@implementation GetSignedBlockRequest

@dynamic start;

typedef struct GetSignedBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t start;
} GetSignedBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = GetSignedBlockRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSignedBlockRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSignedBlockRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSignedBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSignedBlockResponse

@implementation GetSignedBlockResponse

@dynamic hasBlock, block;

typedef struct GetSignedBlockResponse__storage_ {
  uint32_t _has_storage_[1];
  signed_block *block;
} GetSignedBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(signed_block),
        .number = GetSignedBlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSignedBlockResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSignedBlockResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSignedBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountListByBalanceRequest

@implementation GetAccountListByBalanceRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasLastAccount, lastAccount;
@dynamic limit;

typedef struct GetAccountListByBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  coin *start;
  coin *end;
  AccountInfo *lastAccount;
} GetAccountListByBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(coin),
        .number = GetAccountListByBalanceRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountListByBalanceRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(coin),
        .number = GetAccountListByBalanceRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountListByBalanceRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountInfo),
        .number = GetAccountListByBalanceRequest_FieldNumber_LastAccount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAccountListByBalanceRequest__storage_, lastAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetAccountListByBalanceRequest_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetAccountListByBalanceRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountListByBalanceRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountListByBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountListResponse

@implementation GetAccountListResponse

@dynamic listArray, listArray_Count;

typedef struct GetAccountListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} GetAccountListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountResponse),
        .number = GetAccountListResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAccountListResponse__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountListResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DailyTotalTrx

@implementation DailyTotalTrx

@dynamic hasDate, date;
@dynamic count;

typedef struct DailyTotalTrx__storage_ {
  uint32_t _has_storage_[1];
  time_point_sec *date;
  uint64_t count;
} DailyTotalTrx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = DailyTotalTrx_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DailyTotalTrx__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = DailyTotalTrx_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DailyTotalTrx__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DailyTotalTrx class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DailyTotalTrx__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDailyTotalTrxRequest

@implementation GetDailyTotalTrxRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasLastInfo, lastInfo;
@dynamic limit;

typedef struct GetDailyTotalTrxRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  time_point_sec *start;
  time_point_sec *end;
  DailyTotalTrx *lastInfo;
} GetDailyTotalTrxRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetDailyTotalTrxRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDailyTotalTrxRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetDailyTotalTrxRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDailyTotalTrxRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(DailyTotalTrx),
        .number = GetDailyTotalTrxRequest_FieldNumber_LastInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetDailyTotalTrxRequest__storage_, lastInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetDailyTotalTrxRequest_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetDailyTotalTrxRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDailyTotalTrxRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDailyTotalTrxRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDailyTotalTrxResponse

@implementation GetDailyTotalTrxResponse

@dynamic listArray, listArray_Count;

typedef struct GetDailyTotalTrxResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} GetDailyTotalTrxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DailyTotalTrx),
        .number = GetDailyTotalTrxResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDailyTotalTrxResponse__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDailyTotalTrxResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDailyTotalTrxResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StatByHour

@implementation StatByHour

@dynamic hour;
@dynamic count;

typedef struct StatByHour__storage_ {
  uint32_t _has_storage_[1];
  uint32_t hour;
  uint32_t count;
} StatByHour__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hour",
        .dataTypeSpecific.className = NULL,
        .number = StatByHour_FieldNumber_Hour,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StatByHour__storage_, hour),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = StatByHour_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StatByHour__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StatByHour class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StatByHour__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrxStatByHourRequest

@implementation TrxStatByHourRequest

@dynamic hours;

typedef struct TrxStatByHourRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t hours;
} TrxStatByHourRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hours",
        .dataTypeSpecific.className = NULL,
        .number = TrxStatByHourRequest_FieldNumber_Hours,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TrxStatByHourRequest__storage_, hours),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrxStatByHourRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrxStatByHourRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrxStatByHourResponse

@implementation TrxStatByHourResponse

@dynamic statArray, statArray_Count;

typedef struct TrxStatByHourResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *statArray;
} TrxStatByHourResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statArray",
        .dataTypeSpecific.className = GPBStringifySymbol(StatByHour),
        .number = TrxStatByHourResponse_FieldNumber_StatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TrxStatByHourResponse__storage_, statArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrxStatByHourResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrxStatByHourResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrxInfo

@implementation TrxInfo

@dynamic hasTrxId, trxId;
@dynamic blockHeight;
@dynamic hasTrxWrap, trxWrap;
@dynamic hasBlockTime, blockTime;
@dynamic hasBlockId, blockId;
@dynamic blkIsIrreversible;

typedef struct TrxInfo__storage_ {
  uint32_t _has_storage_[1];
  sha256 *trxId;
  transaction_wrapper *trxWrap;
  time_point_sec *blockTime;
  sha256 *blockId;
  uint64_t blockHeight;
} TrxInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trxId",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = TrxInfo_FieldNumber_TrxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TrxInfo__storage_, trxId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = TrxInfo_FieldNumber_BlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TrxInfo__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "trxWrap",
        .dataTypeSpecific.className = GPBStringifySymbol(transaction_wrapper),
        .number = TrxInfo_FieldNumber_TrxWrap,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TrxInfo__storage_, trxWrap),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockTime",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = TrxInfo_FieldNumber_BlockTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TrxInfo__storage_, blockTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = TrxInfo_FieldNumber_BlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TrxInfo__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blkIsIrreversible",
        .dataTypeSpecific.className = NULL,
        .number = TrxInfo_FieldNumber_BlkIsIrreversible,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrxInfo class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrxInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTrxInfoByIdRequest

@implementation GetTrxInfoByIdRequest

@dynamic hasTrxId, trxId;

typedef struct GetTrxInfoByIdRequest__storage_ {
  uint32_t _has_storage_[1];
  sha256 *trxId;
} GetTrxInfoByIdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trxId",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = GetTrxInfoByIdRequest_FieldNumber_TrxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTrxInfoByIdRequest__storage_, trxId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTrxInfoByIdRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTrxInfoByIdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTrxInfoByIdResponse

@implementation GetTrxInfoByIdResponse

@dynamic hasInfo, info;

typedef struct GetTrxInfoByIdResponse__storage_ {
  uint32_t _has_storage_[1];
  TrxInfo *info;
} GetTrxInfoByIdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(TrxInfo),
        .number = GetTrxInfoByIdResponse_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTrxInfoByIdResponse__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTrxInfoByIdResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTrxInfoByIdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTrxListByTimeRequest

@implementation GetTrxListByTimeRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic limit;
@dynamic hasLastInfo, lastInfo;

typedef struct GetTrxListByTimeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  time_point_sec *start;
  time_point_sec *end;
  TrxInfo *lastInfo;
} GetTrxListByTimeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetTrxListByTimeRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTrxListByTimeRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetTrxListByTimeRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTrxListByTimeRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetTrxListByTimeRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTrxListByTimeRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(TrxInfo),
        .number = GetTrxListByTimeRequest_FieldNumber_LastInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetTrxListByTimeRequest__storage_, lastInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTrxListByTimeRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTrxListByTimeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTrxListByTimeResponse

@implementation GetTrxListByTimeResponse

@dynamic listArray, listArray_Count;

typedef struct GetTrxListByTimeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} GetTrxListByTimeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TrxInfo),
        .number = GetTrxListByTimeResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTrxListByTimeResponse__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTrxListByTimeResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTrxListByTimeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostListByCreateTimeRequest

@implementation GetPostListByCreateTimeRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasLastPost, lastPost;
@dynamic limit;

typedef struct GetPostListByCreateTimeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  time_point_sec *start;
  time_point_sec *end;
  PostResponse *lastPost;
} GetPostListByCreateTimeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetPostListByCreateTimeRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPostListByCreateTimeRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetPostListByCreateTimeRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPostListByCreateTimeRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPost",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetPostListByCreateTimeRequest_FieldNumber_LastPost,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPostListByCreateTimeRequest__storage_, lastPost),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetPostListByCreateTimeRequest_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetPostListByCreateTimeRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostListByCreateTimeRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostListByCreateTimeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostListByCreateTimeResponse

@implementation GetPostListByCreateTimeResponse

@dynamic postedListArray, postedListArray_Count;

typedef struct GetPostListByCreateTimeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *postedListArray;
} GetPostListByCreateTimeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postedListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetPostListByCreateTimeResponse_FieldNumber_PostedListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPostListByCreateTimeResponse__storage_, postedListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostListByCreateTimeResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostListByCreateTimeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostListByNameRequest

@implementation GetPostListByNameRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasLastPost, lastPost;
@dynamic limit;

typedef struct GetPostListByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  user_post_create_order *start;
  user_post_create_order *end;
  PostResponse *lastPost;
} GetPostListByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(user_post_create_order),
        .number = GetPostListByNameRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPostListByNameRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(user_post_create_order),
        .number = GetPostListByNameRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPostListByNameRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastPost",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetPostListByNameRequest_FieldNumber_LastPost,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPostListByNameRequest__storage_, lastPost),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetPostListByNameRequest_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetPostListByNameRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostListByNameRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostListByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUserTrxListByTimeRequest

@implementation GetUserTrxListByTimeRequest

@dynamic hasName, name;
@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasLastTrx, lastTrx;
@dynamic limit;

typedef struct GetUserTrxListByTimeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  account_name *name;
  time_point_sec *start;
  time_point_sec *end;
  TrxInfo *lastTrx;
} GetUserTrxListByTimeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetUserTrxListByTimeRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUserTrxListByTimeRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetUserTrxListByTimeRequest_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetUserTrxListByTimeRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetUserTrxListByTimeRequest_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetUserTrxListByTimeRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastTrx",
        .dataTypeSpecific.className = GPBStringifySymbol(TrxInfo),
        .number = GetUserTrxListByTimeRequest_FieldNumber_LastTrx,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetUserTrxListByTimeRequest__storage_, lastTrx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetUserTrxListByTimeRequest_FieldNumber_Limit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetUserTrxListByTimeRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUserTrxListByTimeRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUserTrxListByTimeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUserTrxListByTimeResponse

@implementation GetUserTrxListByTimeResponse

@dynamic trxListArray, trxListArray_Count;

typedef struct GetUserTrxListByTimeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *trxListArray;
} GetUserTrxListByTimeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trxListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TrxInfo),
        .number = GetUserTrxListByTimeResponse_FieldNumber_TrxListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetUserTrxListByTimeResponse__storage_, trxListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUserTrxListByTimeResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUserTrxListByTimeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoterOfPost

@implementation VoterOfPost

@dynamic hasAccountName, accountName;
@dynamic weightedVp;

typedef struct VoterOfPost__storage_ {
  uint32_t _has_storage_[1];
  account_name *accountName;
  uint64_t weightedVp;
} VoterOfPost__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = VoterOfPost_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoterOfPost__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "weightedVp",
        .dataTypeSpecific.className = NULL,
        .number = VoterOfPost_FieldNumber_WeightedVp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoterOfPost__storage_, weightedVp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoterOfPost class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoterOfPost__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostInfoByIdRequest

@implementation GetPostInfoByIdRequest

@dynamic postId;
@dynamic voterListLimit;
@dynamic replyListLimit;

typedef struct GetPostInfoByIdRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t voterListLimit;
  uint32_t replyListLimit;
  uint64_t postId;
} GetPostInfoByIdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postId",
        .dataTypeSpecific.className = NULL,
        .number = GetPostInfoByIdRequest_FieldNumber_PostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPostInfoByIdRequest__storage_, postId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "voterListLimit",
        .dataTypeSpecific.className = NULL,
        .number = GetPostInfoByIdRequest_FieldNumber_VoterListLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPostInfoByIdRequest__storage_, voterListLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "replyListLimit",
        .dataTypeSpecific.className = NULL,
        .number = GetPostInfoByIdRequest_FieldNumber_ReplyListLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPostInfoByIdRequest__storage_, replyListLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostInfoByIdRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostInfoByIdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPostInfoByIdResponse

@implementation GetPostInfoByIdResponse

@dynamic hasPostInfo, postInfo;
@dynamic voterListArray, voterListArray_Count;
@dynamic replyListArray, replyListArray_Count;

typedef struct GetPostInfoByIdResponse__storage_ {
  uint32_t _has_storage_[1];
  PostResponse *postInfo;
  NSMutableArray *voterListArray;
  NSMutableArray *replyListArray;
} GetPostInfoByIdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetPostInfoByIdResponse_FieldNumber_PostInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPostInfoByIdResponse__storage_, postInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voterListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(VoterOfPost),
        .number = GetPostInfoByIdResponse_FieldNumber_VoterListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPostInfoByIdResponse__storage_, voterListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replyListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PostResponse),
        .number = GetPostInfoByIdResponse_FieldNumber_ReplyListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPostInfoByIdResponse__storage_, replyListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPostInfoByIdResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPostInfoByIdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetContractInfoRequest

@implementation GetContractInfoRequest

@dynamic hasOwner, owner;
@dynamic contractName;
@dynamic fetchAbi;
@dynamic fetchCode;

typedef struct GetContractInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  account_name *owner;
  NSString *contractName;
} GetContractInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "owner",
        .dataTypeSpecific.className = GPBStringifySymbol(account_name),
        .number = GetContractInfoRequest_FieldNumber_Owner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetContractInfoRequest__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = GetContractInfoRequest_FieldNumber_ContractName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetContractInfoRequest__storage_, contractName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fetchAbi",
        .dataTypeSpecific.className = NULL,
        .number = GetContractInfoRequest_FieldNumber_FetchAbi,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fetchCode",
        .dataTypeSpecific.className = NULL,
        .number = GetContractInfoRequest_FieldNumber_FetchCode,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetContractInfoRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetContractInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\010\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetContractInfoResponse

@implementation GetContractInfoResponse

@dynamic exist;
@dynamic abi;
@dynamic code;

typedef struct GetContractInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *abi;
  NSData *code;
} GetContractInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exist",
        .dataTypeSpecific.className = NULL,
        .number = GetContractInfoResponse_FieldNumber_Exist,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "abi",
        .dataTypeSpecific.className = NULL,
        .number = GetContractInfoResponse_FieldNumber_Abi,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetContractInfoResponse__storage_, abi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GetContractInfoResponse_FieldNumber_Code,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetContractInfoResponse__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetContractInfoResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetContractInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlkIsIrreversibleByTxIdRequest

@implementation GetBlkIsIrreversibleByTxIdRequest

@dynamic hasTrxId, trxId;

typedef struct GetBlkIsIrreversibleByTxIdRequest__storage_ {
  uint32_t _has_storage_[1];
  sha256 *trxId;
} GetBlkIsIrreversibleByTxIdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trxId",
        .dataTypeSpecific.className = GPBStringifySymbol(sha256),
        .number = GetBlkIsIrreversibleByTxIdRequest_FieldNumber_TrxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlkIsIrreversibleByTxIdRequest__storage_, trxId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlkIsIrreversibleByTxIdRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlkIsIrreversibleByTxIdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlkIsIrreversibleByTxIdResponse

@implementation GetBlkIsIrreversibleByTxIdResponse

@dynamic result;

typedef struct GetBlkIsIrreversibleByTxIdResponse__storage_ {
  uint32_t _has_storage_[1];
} GetBlkIsIrreversibleByTxIdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = GetBlkIsIrreversibleByTxIdResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlkIsIrreversibleByTxIdResponse class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlkIsIrreversibleByTxIdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountListByCreTimeRequest

@implementation GetAccountListByCreTimeRequest

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasLastAccount, lastAccount;
@dynamic limit;

typedef struct GetAccountListByCreTimeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t limit;
  time_point_sec *start;
  time_point_sec *end;
  AccountInfo *lastAccount;
} GetAccountListByCreTimeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetAccountListByCreTimeRequest_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountListByCreTimeRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(time_point_sec),
        .number = GetAccountListByCreTimeRequest_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountListByCreTimeRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountInfo),
        .number = GetAccountListByCreTimeRequest_FieldNumber_LastAccount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAccountListByCreTimeRequest__storage_, lastAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetAccountListByCreTimeRequest_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetAccountListByCreTimeRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountListByCreTimeRequest class]
                                     rootClass:[GrpcRoot class]
                                          file:GrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountListByCreTimeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
